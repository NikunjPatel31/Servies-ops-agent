{"snapshots":{"/home/nikunj-patel/Desktop/Hackathon/agno_knowledge_agent.py":{"filePath":"/home/nikunj-patel/Desktop/Hackathon/agno_knowledge_agent.py","baseContent":"#!/usr/bin/env python3\n\"\"\"\nAdvanced Knowledge Agent using Agno Framework\n==============================================\n\nThis example shows how to create a sophisticated knowledge agent using the Agno framework,\ndemonstrating real-world capabilities like document processing, semantic search, and reasoning.\n\"\"\"\n\nfrom agno.agent import Agent\nfrom agno.models.anthropic import Claude\nfrom agno.knowledge.document import DocumentKnowledge\nfrom agno.knowledge.text import TextKnowledge\nfrom agno.knowledge.pdf import PDFKnowledge\nfrom agno.knowledge.website import WebsiteKnowledge\nfrom agno.vectordb.chroma import ChromaDb\nfrom agno.embedder.openai import OpenAIEmbedder\nfrom agno.tools.reasoning import ReasoningTools\nfrom agno.tools.knowledge import KnowledgeTools\nfrom agno.document.reader.text import TextReader\nfrom agno.document.reader.pdf import PDFReader\nfrom agno.document.reader.website import WebsiteReader\n\nimport os\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional\nimport json\n\nclass SmartKnowledgeAgent:\n    \"\"\"\n    A sophisticated knowledge agent that can:\n    1. Learn from multiple sources (text, PDFs, websites)\n    2. Perform semantic search across knowledge\n    3. Reason about complex queries\n    4. Maintain conversation context\n    5. Provide citations and sources\n    \"\"\"\n    \n    def __init__(self, \n                 name: str = \"SmartKnowledgeBot\",\n                 model_id: str = \"claude-sonnet-4-20250514\",\n                 knowledge_db_path: str = \"./knowledge_db\"):\n        \n        self.name = name\n        self.knowledge_db_path = knowledge_db_path\n        \n        # Ensure knowledge directory exists\n        Path(knowledge_db_path).mkdir(exist_ok=True)\n        \n        # Initialize vector database for knowledge storage\n        self.vector_db = ChromaDb(\n            collection_name=\"smart_knowledge\",\n            path=knowledge_db_path\n        )\n        \n        # Initialize embedder (you'll need OpenAI API key)\n        # For demo purposes, we'll use a simple embedder\n        try:\n            self.embedder = OpenAIEmbedder()\n        except:\n            print(\"⚠️  OpenAI embedder not available, using default\")\n            self.embedder = None\n        \n        # Create knowledge base\n        self.knowledge = DocumentKnowledge(\n            vector_db=self.vector_db,\n            reader=TextReader(),\n            num_documents=10  # Return top 10 relevant documents\n        )\n        \n        # Initialize the agent with advanced capabilities\n        self.agent = Agent(\n            name=self.name,\n            model=Claude(id=model_id),\n            knowledge=self.knowledge,\n            tools=[\n                ReasoningTools(add_instructions=True),\n                KnowledgeTools(knowledge=self.knowledge)\n            ],\n            instructions=[\n                \"You are an intelligent knowledge agent with access to a comprehensive knowledge base.\",\n                \"Always provide accurate, well-reasoned responses based on the available information.\",\n                \"When citing information, reference the sources from your knowledge base.\",\n                \"If you don't have enough information, clearly state what additional information would be helpful.\",\n                \"Use step-by-step reasoning for complex queries.\",\n                \"Format responses clearly with proper structure and citations.\"\n            ],\n            description=\"An advanced AI assistant with deep knowledge capabilities\",\n            add_references=True,  # Include source references\n            search_knowledge=True,  # Enable knowledge search\n            reasoning=True,  # Enable reasoning capabilities\n            markdown=True,  # Format output in markdown\n            show_tool_calls=True,  # Show reasoning steps\n            stream=True  # Stream responses for better UX\n        )\n        \n        print(f\"🤖 {self.name} initialized with advanced knowledge capabilities!\")\n    \n    def learn_from_text(self, text: str, title: str = \"User Input\", metadata: Dict = None) -> str:\n        \"\"\"Add text content to the knowledge base\"\"\"\n        try:\n            if metadata is None:\n                metadata = {}\n\n            metadata.update({\n                'title': title,\n                'type': 'text',\n                'source': 'user_input'\n            })\n\n            # Create a temporary file for the text\n            temp_file = Path(self.knowledge_db_path) / f\"temp_{hash(text)}.txt\"\n            with open(temp_file, 'w', encoding='utf-8') as f:\n                f.write(text)\n\n            # Add to knowledge base\n            text_knowledge = TextKnowledge(\n                path=str(temp_file),\n                vector_db=self.vector_db,\n                reader=TextReader()\n            )\n            text_knowledge.load()\n\n            # Clean up temp file\n            temp_file.unlink()\n\n            return f\"✅ Successfully learned from text: '{title}'\"\n\n        except Exception as e:\n            return f\"❌ Error learning from text: {str(e)}\"\n\n    def learn_api_endpoint(self, method: str, path: str, description: str,\n                          parameters: Dict = None, request_body: Dict = None,\n                          response_example: Dict = None, status_codes: Dict = None) -> str:\n        \"\"\"Add API endpoint documentation to the knowledge base\"\"\"\n        try:\n            # Format the API endpoint documentation\n            endpoint_doc = f\"\"\"\nAPI Endpoint Documentation\n==========================\n\nMethod: {method.upper()}\nPath: {path}\nDescription: {description}\n\n\"\"\"\n\n            # Add parameters section\n            if parameters:\n                endpoint_doc += \"Parameters:\\n\"\n                for param_name, param_desc in parameters.items():\n                    endpoint_doc += f\"- {param_name}: {param_desc}\\n\"\n                endpoint_doc += \"\\n\"\n\n            # Add request body section\n            if request_body:\n                endpoint_doc += \"Request Body:\\n\"\n                if isinstance(request_body, dict):\n                    for field_name, field_desc in request_body.items():\n                        endpoint_doc += f\"- {field_name}: {field_desc}\\n\"\n                else:\n                    endpoint_doc += f\"{request_body}\\n\"\n                endpoint_doc += \"\\n\"\n\n            # Add response example section\n            if response_example:\n                endpoint_doc += \"Response Example:\\n\"\n                if isinstance(response_example, dict):\n                    import json\n                    endpoint_doc += json.dumps(response_example, indent=2)\n                else:\n                    endpoint_doc += str(response_example)\n                endpoint_doc += \"\\n\\n\"\n\n            # Add status codes section\n            if status_codes:\n                endpoint_doc += \"Status Codes:\\n\"\n                for code, desc in status_codes.items():\n                    endpoint_doc += f\"- {code}: {desc}\\n\"\n                endpoint_doc += \"\\n\"\n\n            # Add usage examples\n            endpoint_doc += f\"\"\"\nUsage Examples:\n- Endpoint: {method.upper()} {path}\n- Purpose: {description}\n- HTTP Method: {method.upper()}\n- Full URL Pattern: {path}\n\"\"\"\n\n            # Learn the endpoint documentation\n            result = self.learn_from_text(\n                endpoint_doc,\n                f\"API: {method.upper()} {path}\",\n                {\n                    'type': 'api_endpoint',\n                    'method': method.upper(),\n                    'path': path,\n                    'source': 'api_documentation'\n                }\n            )\n\n            return f\"✅ Successfully learned API endpoint: {method.upper()} {path}\"\n\n        except Exception as e:\n            return f\"❌ Error learning API endpoint: {str(e)}\"\n    \n    def learn_from_file(self, file_path: str, metadata: Dict = None) -> str:\n        \"\"\"Learn from a file (supports various formats)\"\"\"\n        try:\n            file_path = Path(file_path)\n            if not file_path.exists():\n                return f\"❌ File not found: {file_path}\"\n            \n            if metadata is None:\n                metadata = {}\n            \n            metadata.update({\n                'source': str(file_path),\n                'type': 'file'\n            })\n            \n            # Determine file type and use appropriate knowledge class\n            if file_path.suffix.lower() == '.pdf':\n                knowledge = PDFKnowledge(\n                    path=str(file_path),\n                    vector_db=self.vector_db,\n                    reader=PDFReader()\n                )\n            else:\n                # Default to text reader\n                knowledge = TextKnowledge(\n                    path=str(file_path),\n                    vector_db=self.vector_db,\n                    reader=TextReader()\n                )\n            \n            knowledge.load()\n            return f\"✅ Successfully learned from file: {file_path.name}\"\n            \n        except Exception as e:\n            return f\"❌ Error learning from file: {str(e)}\"\n    \n    def learn_from_website(self, url: str, metadata: Dict = None) -> str:\n        \"\"\"Learn from a website URL\"\"\"\n        try:\n            if metadata is None:\n                metadata = {}\n            \n            metadata.update({\n                'source': url,\n                'type': 'website'\n            })\n            \n            website_knowledge = WebsiteKnowledge(\n                urls=[url],\n                vector_db=self.vector_db,\n                reader=WebsiteReader()\n            )\n            website_knowledge.load()\n            \n            return f\"✅ Successfully learned from website: {url}\"\n            \n        except Exception as e:\n            return f\"❌ Error learning from website: {str(e)}\"\n    \n    def ask(self, question: str, show_reasoning: bool = True) -> str:\n        \"\"\"Ask the agent a question\"\"\"\n        try:\n            print(f\"\\n🤔 Processing question: '{question}'\")\n            \n            response = self.agent.run(\n                message=question,\n                stream=False,  # Set to True for streaming\n                show_full_reasoning=show_reasoning\n            )\n            \n            return response.content\n            \n        except Exception as e:\n            return f\"❌ Error processing question: {str(e)}\"\n    \n    def get_knowledge_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about the knowledge base\"\"\"\n        try:\n            # This would depend on the specific vector DB implementation\n            return {\n                'database_path': self.knowledge_db_path,\n                'vector_db_type': type(self.vector_db).__name__,\n                'agent_name': self.name\n            }\n        except Exception as e:\n            return {'error': str(e)}\n    \n    def search_knowledge(self, query: str, num_results: int = 5) -> List[Dict]:\n        \"\"\"Search the knowledge base directly\"\"\"\n        try:\n            results = self.knowledge.search(query, num_documents=num_results)\n            \n            formatted_results = []\n            for doc in results:\n                formatted_results.append({\n                    'content': doc.content[:200] + \"...\" if len(doc.content) > 200 else doc.content,\n                    'metadata': doc.meta_data,\n                    'id': doc.id\n                })\n            \n            return formatted_results\n            \n        except Exception as e:\n            return [{'error': str(e)}]\n\ndef create_sample_knowledge_base(agent: SmartKnowledgeAgent):\n    \"\"\"Create a sample knowledge base for demonstration\"\"\"\n    print(\"\\n📚 Creating sample knowledge base...\")\n    \n    # Sample knowledge about AI and technology\n    knowledge_items = [\n        {\n            'title': 'Artificial Intelligence Basics',\n            'content': '''\n            Artificial Intelligence (AI) is a branch of computer science that aims to create \n            intelligent machines capable of performing tasks that typically require human intelligence. \n            These tasks include learning, reasoning, problem-solving, perception, and language understanding.\n            \n            Key types of AI include:\n            - Narrow AI: Designed for specific tasks (like image recognition)\n            - General AI: Hypothetical AI with human-level intelligence across all domains\n            - Superintelligence: AI that surpasses human intelligence in all areas\n            \n            Current AI applications include virtual assistants, recommendation systems, \n            autonomous vehicles, and medical diagnosis systems.\n            '''\n        },\n        {\n            'title': 'Machine Learning Fundamentals',\n            'content': '''\n            Machine Learning (ML) is a subset of AI that enables computers to learn and improve \n            from experience without being explicitly programmed. ML algorithms build mathematical \n            models based on training data to make predictions or decisions.\n            \n            Main types of machine learning:\n            1. Supervised Learning: Uses labeled training data (classification, regression)\n            2. Unsupervised Learning: Finds patterns in unlabeled data (clustering, dimensionality reduction)\n            3. Reinforcement Learning: Learns through interaction with environment (rewards/penalties)\n            \n            Popular ML algorithms include linear regression, decision trees, neural networks, \n            support vector machines, and ensemble methods like random forests.\n            '''\n        },\n        {\n            'title': 'Vector Databases and Embeddings',\n            'content': '''\n            Vector databases are specialized databases designed to store and query high-dimensional \n            vectors efficiently. They are crucial for AI applications involving semantic search, \n            recommendation systems, and similarity matching.\n            \n            Key concepts:\n            - Embeddings: Dense vector representations of data (text, images, etc.)\n            - Similarity Search: Finding vectors similar to a query vector\n            - Indexing: Efficient data structures for fast vector search (HNSW, IVF, etc.)\n            \n            Popular vector databases include Pinecone, Weaviate, Chroma, Qdrant, and Milvus.\n            Vector databases enable applications like RAG (Retrieval-Augmented Generation), \n            where relevant information is retrieved to enhance AI responses.\n            '''\n        },\n        {\n            'title': 'Knowledge Graphs',\n            'content': '''\n            Knowledge graphs are structured representations of information that model relationships \n            between entities. They consist of nodes (entities) and edges (relationships) forming \n            a network of interconnected knowledge.\n            \n            Components:\n            - Entities: People, places, concepts, objects\n            - Relationships: Connections between entities\n            - Properties: Attributes of entities and relationships\n            \n            Applications include search engines (Google Knowledge Graph), recommendation systems, \n            question answering, and knowledge management systems. Knowledge graphs enable AI systems \n            to understand context and relationships between different pieces of information.\n            '''\n        }\n    ]\n    \n    # Add knowledge to the agent\n    for item in knowledge_items:\n        result = agent.learn_from_text(item['content'], item['title'])\n        print(f\"  {result}\")\n    \n    print(\"✅ Sample knowledge base created!\")\n\ndef demo_smart_agent():\n    \"\"\"Demonstrate the smart knowledge agent\"\"\"\n    print(\"=\" * 70)\n    print(\"🚀 SMART KNOWLEDGE AGENT DEMO (Using Agno Framework)\")\n    print(\"=\" * 70)\n    \n    # Create agent\n    agent = SmartKnowledgeAgent(\"SmartBot\")\n    \n    # Create sample knowledge base\n    create_sample_knowledge_base(agent)\n    \n    # Demo questions\n    questions = [\n        \"What is artificial intelligence and what are its main types?\",\n        \"Explain the difference between supervised and unsupervised learning\",\n        \"How do vector databases work and why are they important for AI?\",\n        \"What are knowledge graphs and how are they used?\",\n        \"Compare machine learning and artificial intelligence\"\n    ]\n    \n    print(\"\\n❓ Asking intelligent questions...\")\n    \n    for i, question in enumerate(questions, 1):\n        print(f\"\\n{'='*50}\")\n        print(f\"Question {i}: {question}\")\n        print('='*50)\n        \n        answer = agent.ask(question, show_reasoning=True)\n        print(f\"\\n📝 Answer:\\n{answer}\")\n    \n    # Show knowledge search capabilities\n    print(f\"\\n{'='*50}\")\n    print(\"🔍 Direct Knowledge Search Demo\")\n    print('='*50)\n    \n    search_query = \"vector databases\"\n    search_results = agent.search_knowledge(search_query, num_results=3)\n    \n    print(f\"Search query: '{search_query}'\")\n    print(\"Results:\")\n    for i, result in enumerate(search_results, 1):\n        if 'error' not in result:\n            print(f\"{i}. {result['content']}\")\n            print(f\"   Metadata: {result['metadata']}\")\n        else:\n            print(f\"Error: {result['error']}\")\n    \n    # Show stats\n    print(f\"\\n📊 Knowledge Base Statistics:\")\n    stats = agent.get_knowledge_stats()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n\nif __name__ == \"__main__\":\n    demo_smart_agent()\n","baseTimestamp":1754023636729,"deltas":[{"timestamp":1754023846747,"changes":[{"type":"INSERT","lineNumber":206,"content":""},{"type":"INSERT","lineNumber":207,"content":"    def learn_from_curl(self, curl_command: str) -> str:"},{"type":"INSERT","lineNumber":208,"content":"        \"\"\"Parse and learn API endpoint from cURL command\"\"\""},{"type":"INSERT","lineNumber":209,"content":"        try:"},{"type":"INSERT","lineNumber":210,"content":"            import re"},{"type":"INSERT","lineNumber":211,"content":"            import json"},{"type":"INSERT","lineNumber":212,"content":""},{"type":"INSERT","lineNumber":213,"content":"            # Extract URL"},{"type":"INSERT","lineNumber":214,"content":"            url_match = re.search(r\"curl\\s+'([^']+)'\", curl_command)"},{"type":"INSERT","lineNumber":215,"content":"            if not url_match:"},{"type":"INSERT","lineNumber":216,"content":"                url_match = re.search(r'curl\\s+\"([^\"]+)\"', curl_command)"},{"type":"INSERT","lineNumber":217,"content":"            if not url_match:"},{"type":"INSERT","lineNumber":218,"content":"                url_match = re.search(r'curl\\s+([^\\s]+)', curl_command)"},{"type":"INSERT","lineNumber":219,"content":""},{"type":"INSERT","lineNumber":220,"content":"            if not url_match:"},{"type":"INSERT","lineNumber":221,"content":"                return \"❌ Could not extract URL from cURL command\""},{"type":"INSERT","lineNumber":222,"content":""},{"type":"INSERT","lineNumber":223,"content":"            full_url = url_match.group(1)"},{"type":"INSERT","lineNumber":224,"content":""},{"type":"INSERT","lineNumber":225,"content":"            # Parse URL components"},{"type":"INSERT","lineNumber":226,"content":"            from urllib.parse import urlparse, parse_qs"},{"type":"INSERT","lineNumber":227,"content":"            parsed_url = urlparse(full_url)"},{"type":"INSERT","lineNumber":228,"content":"            base_path = parsed_url.path"},{"type":"INSERT","lineNumber":229,"content":"            query_params = parse_qs(parsed_url.query)"},{"type":"INSERT","lineNumber":230,"content":""},{"type":"INSERT","lineNumber":231,"content":"            # Extract HTTP method (default to GET if not specified)"},{"type":"INSERT","lineNumber":232,"content":"            method = \"GET\""},{"type":"INSERT","lineNumber":233,"content":"            if \"-X\" in curl_command or \"--request\" in curl_command:"},{"type":"INSERT","lineNumber":234,"content":"                method_match = re.search(r'-X\\s+(\\w+)', curl_command)"},{"type":"INSERT","lineNumber":235,"content":"                if not method_match:"},{"type":"INSERT","lineNumber":236,"content":"                    method_match = re.search(r'--request\\s+(\\w+)', curl_command)"},{"type":"INSERT","lineNumber":237,"content":"                if method_match:"},{"type":"INSERT","lineNumber":238,"content":"                    method = method_match.group(1).upper()"},{"type":"INSERT","lineNumber":239,"content":""},{"type":"INSERT","lineNumber":240,"content":"            # Check for POST data"},{"type":"INSERT","lineNumber":241,"content":"            if \"--data\" in curl_command or \"-d\" in curl_command:"},{"type":"INSERT","lineNumber":242,"content":"                method = \"POST\""},{"type":"INSERT","lineNumber":243,"content":""},{"type":"INSERT","lineNumber":244,"content":"            # Extract headers"},{"type":"INSERT","lineNumber":245,"content":"            headers = {}"},{"type":"INSERT","lineNumber":246,"content":"            header_matches = re.findall(r\"-H\\s+'([^']+)'\", curl_command)"},{"type":"INSERT","lineNumber":247,"content":"            if not header_matches:"},{"type":"INSERT","lineNumber":248,"content":"                header_matches = re.findall(r'-H\\s+\"([^\"]+)\"', curl_command)"},{"type":"INSERT","lineNumber":249,"content":""},{"type":"INSERT","lineNumber":250,"content":"            for header in header_matches:"},{"type":"INSERT","lineNumber":251,"content":"                if ':' in header:"},{"type":"INSERT","lineNumber":252,"content":"                    key, value = header.split(':', 1)"},{"type":"INSERT","lineNumber":253,"content":"                    headers[key.strip()] = value.strip()"},{"type":"INSERT","lineNumber":254,"content":""},{"type":"INSERT","lineNumber":255,"content":"            # Extract request body"},{"type":"INSERT","lineNumber":256,"content":"            request_body = None"},{"type":"INSERT","lineNumber":257,"content":"            data_match = re.search(r\"--data-raw\\s+'([^']+)'\", curl_command)"},{"type":"INSERT","lineNumber":258,"content":"            if not data_match:"},{"type":"INSERT","lineNumber":259,"content":"                data_match = re.search(r'--data-raw\\s+\"([^\"]+)\"', curl_command)"},{"type":"INSERT","lineNumber":260,"content":"            if not data_match:"},{"type":"INSERT","lineNumber":261,"content":"                data_match = re.search(r\"--data\\s+'([^']+)'\", curl_command)"},{"type":"INSERT","lineNumber":262,"content":"            if not data_match:"},{"type":"INSERT","lineNumber":263,"content":"                data_match = re.search(r'-d\\s+\"([^\"]+)\"', curl_command)"},{"type":"INSERT","lineNumber":264,"content":""},{"type":"INSERT","lineNumber":265,"content":"            if data_match:"},{"type":"INSERT","lineNumber":266,"content":"                try:"},{"type":"INSERT","lineNumber":267,"content":"                    request_body = json.loads(data_match.group(1))"},{"type":"INSERT","lineNumber":268,"content":"                except:"},{"type":"INSERT","lineNumber":269,"content":"                    request_body = data_match.group(1)"},{"type":"INSERT","lineNumber":270,"content":""},{"type":"INSERT","lineNumber":271,"content":"            # Create comprehensive documentation"},{"type":"INSERT","lineNumber":272,"content":"            endpoint_doc = f\"\"\""},{"type":"INSERT","lineNumber":273,"content":"API Endpoint Documentation (from cURL)"},{"type":"INSERT","lineNumber":274,"content":"======================================"},{"type":"INSERT","lineNumber":275,"content":""},{"type":"INSERT","lineNumber":276,"content":"Method: {method}"},{"type":"INSERT","lineNumber":277,"content":"URL: {full_url}"},{"type":"INSERT","lineNumber":278,"content":"Base Path: {base_path}"},{"type":"INSERT","lineNumber":279,"content":"Host: {parsed_url.netloc}"},{"type":"INSERT","lineNumber":280,"content":""},{"type":"INSERT","lineNumber":281,"content":"\"\"\""},{"type":"INSERT","lineNumber":282,"content":""},{"type":"INSERT","lineNumber":283,"content":"            # Add query parameters"},{"type":"INSERT","lineNumber":284,"content":"            if query_params:"},{"type":"INSERT","lineNumber":285,"content":"                endpoint_doc += \"Query Parameters:\\n\""},{"type":"INSERT","lineNumber":286,"content":"                for param, values in query_params.items():"},{"type":"INSERT","lineNumber":287,"content":"                    endpoint_doc += f\"- {param}: {', '.join(values)}\\n\""},{"type":"INSERT","lineNumber":288,"content":"                endpoint_doc += \"\\n\""},{"type":"INSERT","lineNumber":289,"content":""},{"type":"INSERT","lineNumber":290,"content":"            # Add headers"},{"type":"INSERT","lineNumber":291,"content":"            if headers:"},{"type":"INSERT","lineNumber":292,"content":"                endpoint_doc += \"Headers:\\n\""},{"type":"INSERT","lineNumber":293,"content":"                for header_name, header_value in headers.items():"},{"type":"INSERT","lineNumber":294,"content":"                    # Mask sensitive headers"},{"type":"INSERT","lineNumber":295,"content":"                    if header_name.lower() in ['authorization', 'cookie']:"},{"type":"INSERT","lineNumber":296,"content":"                        masked_value = header_value[:20] + \"...\" if len(header_value) > 20 else \"[MASKED]\""},{"type":"INSERT","lineNumber":297,"content":"                        endpoint_doc += f\"- {header_name}: {masked_value}\\n\""},{"type":"INSERT","lineNumber":298,"content":"                    else:"},{"type":"INSERT","lineNumber":299,"content":"                        endpoint_doc += f\"- {header_name}: {header_value}\\n\""},{"type":"INSERT","lineNumber":300,"content":"                endpoint_doc += \"\\n\""},{"type":"INSERT","lineNumber":301,"content":""},{"type":"INSERT","lineNumber":302,"content":"            # Add request body"},{"type":"INSERT","lineNumber":303,"content":"            if request_body:"},{"type":"INSERT","lineNumber":304,"content":"                endpoint_doc += \"Request Body:\\n\""},{"type":"INSERT","lineNumber":305,"content":"                if isinstance(request_body, dict):"},{"type":"INSERT","lineNumber":306,"content":"                    endpoint_doc += json.dumps(request_body, indent=2)"},{"type":"INSERT","lineNumber":307,"content":"                else:"},{"type":"INSERT","lineNumber":308,"content":"                    endpoint_doc += str(request_body)"},{"type":"INSERT","lineNumber":309,"content":"                endpoint_doc += \"\\n\\n\""},{"type":"INSERT","lineNumber":310,"content":""},{"type":"INSERT","lineNumber":311,"content":"            # Add usage information"},{"type":"INSERT","lineNumber":312,"content":"            endpoint_doc += f\"\"\""},{"type":"INSERT","lineNumber":313,"content":"Usage Information:"},{"type":"INSERT","lineNumber":314,"content":"- HTTP Method: {method}"},{"type":"INSERT","lineNumber":315,"content":"- Endpoint: {base_path}"},{"type":"INSERT","lineNumber":316,"content":"- Full URL: {full_url}"},{"type":"INSERT","lineNumber":317,"content":"- Content-Type: {headers.get('Content-Type', 'Not specified')}"},{"type":"INSERT","lineNumber":318,"content":"- Authentication: {'Required (Bearer token)' if 'Authorization' in headers else 'Not specified'}"},{"type":"INSERT","lineNumber":319,"content":""},{"type":"INSERT","lineNumber":320,"content":"cURL Command:"},{"type":"INSERT","lineNumber":321,"content":"{curl_command[:200]}..."},{"type":"INSERT","lineNumber":322,"content":"\"\"\""},{"type":"INSERT","lineNumber":323,"content":""},{"type":"INSERT","lineNumber":324,"content":"            # Learn the endpoint"},{"type":"INSERT","lineNumber":325,"content":"            result = self.learn_from_text("},{"type":"INSERT","lineNumber":326,"content":"                endpoint_doc,"},{"type":"INSERT","lineNumber":327,"content":"                f\"cURL API: {method} {base_path}\","},{"type":"INSERT","lineNumber":328,"content":"                {"},{"type":"INSERT","lineNumber":329,"content":"                    'type': 'curl_api',"},{"type":"INSERT","lineNumber":330,"content":"                    'method': method,"},{"type":"INSERT","lineNumber":331,"content":"                    'path': base_path,"},{"type":"INSERT","lineNumber":332,"content":"                    'host': parsed_url.netloc,"},{"type":"INSERT","lineNumber":333,"content":"                    'source': 'curl_command'"},{"type":"INSERT","lineNumber":334,"content":"                }"},{"type":"INSERT","lineNumber":335,"content":"            )"},{"type":"INSERT","lineNumber":336,"content":""},{"type":"INSERT","lineNumber":337,"content":"            return f\"✅ Successfully learned API from cURL: {method} {base_path}\""},{"type":"INSERT","lineNumber":338,"content":""},{"type":"INSERT","lineNumber":339,"content":"        except Exception as e:"},{"type":"INSERT","lineNumber":340,"content":"            return f\"❌ Error parsing cURL command: {str(e)}\""}]}]},"/home/nikunj-patel/Desktop/Hackathon/curl_api_trainer.py":{"filePath":"/home/nikunj-patel/Desktop/Hackathon/curl_api_trainer.py","baseContent":"#!/usr/bin/env python3\n\"\"\"\ncURL API Trainer\n================\n\nTrain the knowledge agent to understand API endpoints from cURL commands.\nThis script can parse cURL commands and teach the agent about the APIs.\n\"\"\"\n\nfrom knowledge_agent_tutorial import KnowledgeAgent\nimport re\nimport json\nfrom urllib.parse import urlparse, parse_qs\nimport requests\nimport torch\nfrom transformers import AutoTokenizer, AutoModel\nimport numpy as np\n\nclass CurlAPITrainer:\n    \"\"\"Agent that learns API endpoints from cURL commands\"\"\"\n    \n    def __init__(self, agent_name=\"CurlAPIAgent\"):\n        self.agent = KnowledgeAgent(agent_name)\n        self.learned_apis = []\n        self._load_basic_knowledge()\n    \n    def _load_basic_knowledge(self):\n        \"\"\"Load basic API and cURL knowledge\"\"\"\n        basic_knowledge = [\n            {\n                \"title\": \"cURL Basics\",\n                \"content\": \"\"\"\n                cURL is a command-line tool for transferring data with URLs.\n                Common cURL options:\n                - -H: Add headers\n                - -X: Specify HTTP method\n                - -d, --data: Send POST data\n                - --data-raw: Send raw POST data\n                - -u: Authentication\n                - --insecure: Skip SSL verification\n                \n                HTTP Methods:\n                - GET: Retrieve data\n                - POST: Send data to server\n                - PUT: Update resource\n                - DELETE: Remove resource\n                \"\"\"\n            },\n            {\n                \"title\": \"API Authentication\",\n                \"content\": \"\"\"\n                Common API authentication methods:\n                - Bearer Token: Authorization: Bearer <token>\n                - Basic Auth: -u username:password\n                - API Key: X-API-Key: <key>\n                - Cookie-based: --cookie or -b\n                \n                Security considerations:\n                - Always use HTTPS in production\n                - Keep tokens secure and rotate regularly\n                - Use appropriate token scopes\n                \"\"\"\n            }\n        ]\n        \n        for knowledge in basic_knowledge:\n            self.agent.learn_from_text(knowledge[\"content\"], knowledge[\"title\"])\n    \n    def parse_curl_command(self, curl_command: str) -> dict:\n        \"\"\"Parse cURL command and extract API information\"\"\"\n        api_info = {\n            'method': 'GET',\n            'url': '',\n            'path': '',\n            'host': '',\n            'query_params': {},\n            'headers': {},\n            'request_body': None,\n            'description': '',\n            'raw_curl': curl_command\n        }\n        \n        try:\n            # Extract URL\n            url_match = re.search(r\"curl\\s+'([^']+)'\", curl_command)\n            if not url_match:\n                url_match = re.search(r'curl\\s+\"([^\"]+)\"', curl_command)\n            if not url_match:\n                url_match = re.search(r'curl\\s+([^\\s\\\\]+)', curl_command)\n            \n            if url_match:\n                api_info['url'] = url_match.group(1)\n                parsed_url = urlparse(api_info['url'])\n                api_info['path'] = parsed_url.path\n                api_info['host'] = parsed_url.netloc\n                api_info['query_params'] = parse_qs(parsed_url.query)\n            \n            # Extract HTTP method\n            method_match = re.search(r'-X\\s+(\\w+)', curl_command)\n            if not method_match:\n                method_match = re.search(r'--request\\s+(\\w+)', curl_command)\n            if method_match:\n                api_info['method'] = method_match.group(1).upper()\n            \n            # Check for POST data (implies POST method)\n            if \"--data\" in curl_command or \"-d\" in curl_command:\n                api_info['method'] = \"POST\"\n            \n            # Extract headers\n            header_matches = re.findall(r\"-H\\s+'([^']+)'\", curl_command)\n            if not header_matches:\n                header_matches = re.findall(r'-H\\s+\"([^\"]+)\"', curl_command)\n            \n            for header in header_matches:\n                if ':' in header:\n                    key, value = header.split(':', 1)\n                    api_info['headers'][key.strip()] = value.strip()\n            \n            # Extract request body\n            data_match = re.search(r\"--data-raw\\s+'([^']+)'\", curl_command, re.DOTALL)\n            if not data_match:\n                data_match = re.search(r'--data-raw\\s+\"([^\"]+)\"', curl_command, re.DOTALL)\n            if not data_match:\n                data_match = re.search(r\"--data\\s+'([^']+)'\", curl_command, re.DOTALL)\n            if not data_match:\n                data_match = re.search(r'-d\\s+\"([^\"]+)\"', curl_command, re.DOTALL)\n            \n            if data_match:\n                try:\n                    api_info['request_body'] = json.loads(data_match.group(1))\n                except:\n                    api_info['request_body'] = data_match.group(1)\n            \n            # Generate description based on path and method\n            api_info['description'] = self._generate_description(api_info)\n            \n        except Exception as e:\n            print(f\"Error parsing cURL: {e}\")\n        \n        return api_info\n    \n    def _generate_description(self, api_info: dict) -> str:\n        \"\"\"Generate a description for the API endpoint\"\"\"\n        path = api_info['path']\n        method = api_info['method']\n        \n        # Try to infer purpose from path\n        if 'search' in path.lower():\n            return f\"{method} endpoint for searching data\"\n        elif 'create' in path.lower() or method == 'POST':\n            return f\"{method} endpoint for creating new resources\"\n        elif 'update' in path.lower() or method == 'PUT':\n            return f\"{method} endpoint for updating resources\"\n        elif 'delete' in path.lower() or method == 'DELETE':\n            return f\"{method} endpoint for deleting resources\"\n        elif method == 'GET':\n            return f\"{method} endpoint for retrieving data\"\n        else:\n            return f\"{method} endpoint for {path}\"\n    \n    def learn_from_curl(self, curl_command: str) -> str:\n        \"\"\"Learn API endpoint from cURL command\"\"\"\n        try:\n            print(\"🔍 Parsing cURL command...\")\n            api_info = self.parse_curl_command(curl_command)\n            \n            if not api_info['url']:\n                return \"❌ Could not extract URL from cURL command\"\n            \n            print(f\"📋 Detected: {api_info['method']} {api_info['path']}\")\n            print(f\"🌐 Host: {api_info['host']}\")\n            \n            # Create comprehensive documentation\n            doc_text = self._create_api_documentation(api_info)\n            \n            # Learn the API\n            result = self.agent.learn_from_text(\n                doc_text,\n                f\"API: {api_info['method']} {api_info['path']}\"\n            )\n            \n            # Track learned APIs\n            self.learned_apis.append(api_info)\n            \n            return f\"✅ Successfully learned: {api_info['method']} {api_info['path']}\"\n            \n        except Exception as e:\n            return f\"❌ Error learning from cURL: {str(e)}\"\n    \n    def _create_api_documentation(self, api_info: dict) -> str:\n        \"\"\"Create comprehensive API documentation\"\"\"\n        doc = f\"\"\"\nAPI Endpoint Documentation\n==========================\n\nMethod: {api_info['method']}\nURL: {api_info['url']}\nPath: {api_info['path']}\nHost: {api_info['host']}\nDescription: {api_info['description']}\n\n\"\"\"\n        \n        # Add query parameters\n        if api_info['query_params']:\n            doc += \"Query Parameters:\\n\"\n            for param, values in api_info['query_params'].items():\n                doc += f\"- {param}: {', '.join(values)}\\n\"\n            doc += \"\\n\"\n        \n        # Add headers (mask sensitive ones)\n        if api_info['headers']:\n            doc += \"Required Headers:\\n\"\n            for header_name, header_value in api_info['headers'].items():\n                if header_name.lower() in ['authorization', 'cookie']:\n                    doc += f\"- {header_name}: [Authentication token required]\\n\"\n                else:\n                    doc += f\"- {header_name}: {header_value}\\n\"\n            doc += \"\\n\"\n        \n        # Add request body\n        if api_info['request_body']:\n            doc += \"Request Body:\\n\"\n            if isinstance(api_info['request_body'], dict):\n                doc += json.dumps(api_info['request_body'], indent=2)\n            else:\n                doc += str(api_info['request_body'])\n            doc += \"\\n\\n\"\n        \n        # Add usage information\n        doc += f\"\"\"\nUsage Information:\n- HTTP Method: {api_info['method']}\n- Endpoint Path: {api_info['path']}\n- Authentication: {'Required (Bearer token)' if 'Authorization' in api_info['headers'] else 'Not specified'}\n- Content-Type: {api_info['headers'].get('Content-Type', 'Not specified')}\n\nExample Usage:\n{api_info['method']} {api_info['path']}\nHost: {api_info['host']}\n\"\"\"\n        \n        return doc\n    \n    def ask_about_api(self, question: str) -> str:\n        \"\"\"Ask questions about learned APIs\"\"\"\n        return self.agent.ask(question)\n    \n    def list_learned_apis(self) -> str:\n        \"\"\"List all learned APIs\"\"\"\n        if not self.learned_apis:\n            return \"📝 No APIs learned yet.\"\n        \n        result = \"📋 Learned APIs:\\n\"\n        for i, api in enumerate(self.learned_apis, 1):\n            result += f\"{i}. {api['method']} {api['path']} - {api['description']}\\n\"\n        \n        return result\n    \n    def get_stats(self) -> dict:\n        \"\"\"Get training statistics\"\"\"\n        stats = self.agent.get_stats()\n        stats['learned_apis'] = len(self.learned_apis)\n        return stats\n\ndef train_with_your_curl():\n    \"\"\"Train the agent with your specific cURL command\"\"\"\n    print(\"🎯 TRAINING AGENT WITH YOUR cURL API\")\n    print(\"=\" * 50)\n    \n    # Your specific cURL command\n    your_curl_command = \"\"\"curl 'http://172.16.15.113/api/request/search/byqual?offset=0&size=25&sort_by=createdTime' \\\\\n  -H 'Accept: application/json, text/plain, */*' \\\\\n  -H 'Accept-Language: en-GB,en;q=0.9' \\\\\n  -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dpbl9zc29faWQiOjAsInVzZXJfbmFtZSI6InV1aWQzNi04OWRiOTc1My0zYTA5LTQzYTgtYTIzYS03ZjMwOGJkNDIyMWEiLCJzY29wZSI6WyJOTy1TQ09QRSJdLCJsb2dpbl9zb3VyY2UiOiJub3JtYWxfbG9naW4iLCJleHAiOjE3NTQxOTQxNzgsImxvZ2luX21zcF9wb3J0YWxfaWQiOjAsImp0aSI6ImM3ZjVlOWEzLTY0ZjEtNGM0OC1hZGMyLWVmNDViZDdjMDQyMyIsImNsaWVudF9pZCI6ImZsb3RvLXdlYi1hcHAiLCJ0ZW5hbnRJZGVudGlmaWVyIjoiYXBvbG8ifQ.szRg8KGAXtnCOGFeLC_t2p_mMPSSf2dGGuCL1GlPOXDnkGG8xa3qG9gDDWs7yb19lARFpjOOZCSbaY_gfoN-X9rLHQHLmci7L5GPvJFUAf3sxt-UwcnPX8fs8W89jpnME26lO7wolGsDPXHrcBl689x-lJLgFvl-fZ7vfA7jv7v0SZ16SV-FRCahISYcSWNCPED6ajb4tc14ytBpmuSqBvdic2HFWRlUHNHkdA8puLIEmnISHSapwWxIkm3PwidF-9fTQ9nht_oSsA-E2iznolmbfExPX_uvrsaY0CKZI_JNaD6rlyFdlWdjEA515q2-8_w9zB97yznWjW2FBsbX6g' \\\\\n  -H 'Connection: keep-alive' \\\\\n  -H 'Content-Type: application/json' \\\\\n  -H 'Origin: http://172.16.15.113' \\\\\n  -H 'Referer: http://172.16.15.113/t/request/' \\\\\n  -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36' \\\\\n  --data-raw '{\"qualDetails\":{\"type\":\"FlatQualificationRest\",\"quals\":[{\"description\":null,\"qualContext\":null,\"type\":\"RelationalQualificationRest\",\"leftOperand\":{\"type\":\"PropertyOperandRest\",\"key\":\"request.statusId\"},\"operator\":\"not_in\",\"rightOperand\":{\"type\":\"ValueOperandRest\",\"value\":{\"type\":\"ListLongValueRest\",\"value\":[13]}}}]}}' \\\\\n  --insecure\"\"\"\n    \n    # Create trainer\n    trainer = CurlAPITrainer(\"YourAPIAgent\")\n    \n    # Train with your cURL\n    print(\"📚 Training agent with your cURL command...\")\n    result = trainer.learn_from_curl(your_curl_command)\n    print(result)\n    \n    # Show what was learned\n    print(f\"\\n{trainer.list_learned_apis()}\")\n    \n    # Test the agent's knowledge\n    print(\"\\n❓ Testing agent's understanding...\")\n    test_questions = [\n        \"What is the endpoint for searching requests?\",\n        \"What parameters does the search API accept?\",\n        \"What authentication is required?\",\n        \"What is the request body format?\",\n        \"How do I search for requests with specific qualifications?\"\n    ]\n    \n    for i, question in enumerate(test_questions, 1):\n        print(f\"\\n{i}. Q: {question}\")\n        answer = trainer.ask_about_api(question)\n        # Show first part of answer\n        short_answer = answer.split('\\n')[0][:120] + \"...\"\n        print(f\"   A: {short_answer}\")\n    \n    # Show stats\n    stats = trainer.get_stats()\n    print(f\"\\n📊 Training Complete!\")\n    print(f\"   🎯 APIs Learned: {stats['learned_apis']}\")\n    print(f\"   📚 Total Documents: {stats['total_documents']}\")\n    print(f\"   💬 Questions Answered: {stats['conversations']}\")\n    \n    return trainer\n\ndef interactive_curl_trainer():\n    \"\"\"Interactive mode for training with cURL commands\"\"\"\n    print(\"🔧 INTERACTIVE cURL API TRAINER\")\n    print(\"=\" * 40)\n    print(\"Paste your cURL commands and I'll learn the APIs!\")\n    print(\"Commands: 'stats', 'list', 'help', 'quit'\")\n    print(\"=\" * 40)\n    \n    trainer = CurlAPITrainer()\n    \n    while True:\n        try:\n            print(\"\\n🔧 Paste your cURL command (or type a command):\")\n            user_input = input(\"> \").strip()\n            \n            if not user_input:\n                continue\n            \n            if user_input.lower() in ['quit', 'exit']:\n                print(\"👋 Happy coding!\")\n                break\n            elif user_input.lower() == 'help':\n                print(\"\\n📚 HELP:\")\n                print(\"• Paste cURL command to learn API\")\n                print(\"• 'list' - Show learned APIs\")\n                print(\"• 'stats' - Show statistics\")\n                print(\"• 'quit' - Exit\")\n            elif user_input.lower() == 'list':\n                print(trainer.list_learned_apis())\n            elif user_input.lower() == 'stats':\n                stats = trainer.get_stats()\n                print(f\"\\n📊 STATISTICS:\")\n                print(f\"   🎯 APIs Learned: {stats['learned_apis']}\")\n                print(f\"   📚 Total Documents: {stats['total_documents']}\")\n            elif user_input.startswith('curl'):\n                result = trainer.learn_from_curl(user_input)\n                print(result)\n            else:\n                # Treat as question\n                answer = trainer.ask_about_api(user_input)\n                print(f\"🤖 {answer}\")\n        \n        except KeyboardInterrupt:\n            print(\"\\n👋 Happy coding!\")\n            break\n        except Exception as e:\n            print(f\"❌ Error: {e}\")\n\nif __name__ == \"__main__\":\n    import sys\n    \n    if len(sys.argv) > 1 and sys.argv[1] == 'interactive':\n        interactive_curl_trainer()\n    else:\n        train_with_your_curl()\n","baseTimestamp":1754024497680},"/home/nikunj-patel/Desktop/Hackathon/src/api_endpoint_server.py":{"filePath":"/home/nikunj-patel/Desktop/Hackathon/src/api_endpoint_server.py","baseContent":"#!/usr/bin/env python3\n\"\"\"\nAPI Endpoint Server\n===================\n\nFlask server that takes user prompts and executes the appropriate API calls.\nUser sends: {\"request\": \"Get all the request with priority as low\"}\nServer responds with actual API results.\n\"\"\"\n\nfrom flask import Flask, request, jsonify\nfrom request_search_api_agent import RequestSearchAPIAgent\nimport requests\nimport json\nimport re\nfrom urllib.parse import urlencode\nimport sys\nimport os\n\n# Add config to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'config'))\nfrom api_config import APIConfig\n\napp = Flask(__name__)\n\nclass APIExecutor:\n    \"\"\"Executes API calls based on user prompts\"\"\"\n\n    def __init__(self):\n        self.agent = RequestSearchAPIAgent(\"APIExecutor\")\n        # Use configuration\n        self.config = APIConfig\n\n        # Token cache\n        self.cached_token = None\n        self.token_expiry = None\n\n        # Status mapping cache\n        self.status_mapping = {}\n        self.status_mapping_loaded = False\n\n    def get_access_token(self):\n        \"\"\"Get access token using OAuth endpoint\"\"\"\n        try:\n            # Check if we have a valid cached token\n            if self.cached_token and self.token_expiry:\n                import datetime\n                if datetime.datetime.now() < self.token_expiry:\n                    return self.cached_token\n\n            print(\"🔑 Fetching new access token...\")\n\n            # Prepare OAuth request\n            headers = {\n                'Accept': '*/*',\n                'Accept-Language': 'en-GB,en;q=0.9',\n                'Authorization': self.config.CLIENT_AUTH,\n                'Connection': 'keep-alive',\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Origin': self.config.BASE_URL,\n                'Referer': f'{self.config.BASE_URL}/login?redirectFrom=%2Ft%2Frequest%2F',\n                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'\n            }\n\n            # Prepare form data\n            data = {\n                'username': self.config.USERNAME,\n                'password': self.config.PASSWORD,\n                'grant_type': 'password'\n            }\n\n            # Make OAuth request\n            response = requests.post(\n                self.config.OAUTH_URL,\n                headers=headers,\n                data=data,\n                verify=False,  # --insecure equivalent\n                timeout=self.config.REQUEST_TIMEOUT\n            )\n\n            if response.status_code == 200:\n                token_data = response.json()\n                access_token = token_data.get('access_token')\n                expires_in = token_data.get('expires_in', 3600)  # Default 1 hour\n\n                if access_token:\n                    # Cache the token\n                    self.cached_token = access_token\n                    import datetime\n                    self.token_expiry = datetime.datetime.now() + datetime.timedelta(seconds=expires_in - self.config.TOKEN_REFRESH_BUFFER)\n\n                    print(f\"✅ Token obtained successfully (expires in {expires_in}s)\")\n                    return access_token\n                else:\n                    print(\"❌ No access token in response\")\n                    return None\n            else:\n                print(f\"❌ OAuth failed: {response.status_code} - {response.text}\")\n                return None\n\n        except Exception as e:\n            print(f\"❌ Token retrieval error: {str(e)}\")\n            return None\n\n    def get_status_mapping(self):\n        \"\"\"Get status mapping from the API with fallback\"\"\"\n        try:\n            # Return cached mapping if available\n            if self.status_mapping_loaded:\n                return self.status_mapping\n\n            print(\"📋 Fetching status mapping...\")\n\n            # Get access token\n            auth_token = self.get_access_token()\n            if not auth_token:\n                print(\"❌ Cannot fetch status mapping - no auth token\")\n                return self._get_fallback_status_mapping()\n\n            # Prepare headers\n            headers = {\n                'Accept': 'application/json, text/plain, */*',\n                'Accept-Language': 'en-IN,en-GB;q=0.9,en-US;q=0.8,en;q=0.7',\n                'Authorization': f'Bearer {auth_token}',\n                'Connection': 'keep-alive',\n                'Content-Type': 'application/json',\n                'Origin': self.config.BASE_URL,\n                'Referer': f'{self.config.BASE_URL}/admin/status/?type=request',\n                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36'\n            }\n\n            # Make status API request\n            response = requests.post(\n                self.config.STATUS_SEARCH_URL,\n                headers=headers,\n                json={},  # Empty body as per your example\n                verify=False,\n                timeout=self.config.REQUEST_TIMEOUT\n            )\n\n            if response.status_code == 200:\n                try:\n                    response_data = response.json()\n\n                    # Handle different response formats\n                    if isinstance(response_data, list):\n                        statuses = response_data\n                    elif isinstance(response_data, dict):\n                        # Check if it's a paginated response\n                        if 'objectList' in response_data:\n                            statuses = response_data['objectList']\n                        elif 'content' in response_data:\n                            statuses = response_data['content']\n                        else:\n                            # Assume the dict itself contains status data\n                            statuses = [response_data]\n                    else:\n                        print(f\"❌ Unexpected response format: {type(response_data)}\")\n                        return self._get_fallback_status_mapping()\n\n                    # Build status mapping: name -> id\n                    self.status_mapping = {}\n                    for status in statuses:\n                        if not isinstance(status, dict):\n                            print(f\"❌ Expected dict, got: {type(status)}\")\n                            continue\n\n                        status_name = status.get('name', '').lower()\n                        status_id = status.get('id')\n                        system_name = status.get('systemName', '').lower()\n\n                        if status_name and status_id:\n                            self.status_mapping[status_name] = status_id\n                            # Also map system name if different\n                            if system_name and system_name != status_name:\n                                self.status_mapping[system_name] = status_id\n\n                except json.JSONDecodeError as e:\n                    print(f\"❌ JSON decode error: {e}\")\n                    print(f\"   Response text: {response.text[:200]}...\")\n                    return self._get_fallback_status_mapping()\n\n                self.status_mapping_loaded = True\n                print(f\"✅ Status mapping loaded: {len(self.status_mapping)} statuses\")\n                print(f\"   Available statuses: {list(self.status_mapping.keys())}\")\n\n                return self.status_mapping\n            else:\n                print(f\"❌ Status API failed: {response.status_code}\")\n                if response.status_code == 502:\n                    print(\"   Server error - using fallback status mapping\")\n                return self._get_fallback_status_mapping()\n\n        except Exception as e:\n            print(f\"❌ Status mapping error: {str(e)}\")\n            return self._get_fallback_status_mapping()\n\n    def _get_fallback_status_mapping(self):\n        \"\"\"Fallback status mapping based on common statuses\"\"\"\n        print(\"🔄 Using fallback status mapping\")\n        fallback_mapping = {\n            \"open\": 9,\n            \"in progress\": 10,\n            \"pending\": 11,\n            \"resolved\": 12,\n            \"closed\": 13,\n            \"testing1\": 14  # Based on your example\n        }\n\n        self.status_mapping = fallback_mapping\n        self.status_mapping_loaded = True\n        print(f\"✅ Fallback status mapping loaded: {len(fallback_mapping)} statuses\")\n        print(f\"   Available statuses: {list(fallback_mapping.keys())}\")\n\n        return fallback_mapping\n    \n    def parse_user_prompt(self, user_prompt):\n        \"\"\"Parse user prompt and determine API parameters\"\"\"\n        prompt_lower = user_prompt.lower()\n        \n        # Default parameters from config\n        params = {\n            \"offset\": self.config.DEFAULT_OFFSET,\n            \"size\": self.config.DEFAULT_SIZE,\n            \"sort_by\": self.config.DEFAULT_SORT_BY\n        }\n        \n        # Parse pagination\n        if \"first\" in prompt_lower or \"page 1\" in prompt_lower:\n            params[\"offset\"] = 0\n        elif \"next\" in prompt_lower or \"page 2\" in prompt_lower:\n            params[\"offset\"] = 25\n        elif \"more\" in prompt_lower:\n            params[\"size\"] = 50\n        \n        # Parse sorting\n        if \"sort by priority\" in prompt_lower or \"priority order\" in prompt_lower:\n            params[\"sort_by\"] = \"priority\"\n        elif \"sort by date\" in prompt_lower or \"creation time\" in prompt_lower:\n            params[\"sort_by\"] = \"createdTime\"\n        \n        return params\n    \n    def extract_priority_filter(self, user_prompt):\n        \"\"\"Extract priority filter from user prompt\"\"\"\n        prompt_lower = user_prompt.lower()\n        \n        priority_ids = []\n        for priority_name, priority_id in self.config.PRIORITY_MAPPING.items():\n            if priority_name in prompt_lower:\n                priority_ids.append(priority_id)\n        \n        return priority_ids\n\n    def extract_status_filter(self, user_prompt):\n        \"\"\"Extract status filter from user prompt\"\"\"\n        prompt_lower = user_prompt.lower()\n\n        # Get status mapping\n        status_mapping = self.get_status_mapping()\n        if not status_mapping:\n            return []\n\n        status_ids = []\n\n        # Check for specific status mentions\n        for status_name, status_id in status_mapping.items():\n            if status_name in prompt_lower:\n                status_ids.append(status_id)\n\n        # Remove duplicates\n        status_ids = list(set(status_ids))\n\n        return status_ids\n\n    def extract_request_id(self, user_prompt):\n        \"\"\"Extract specific request ID from user prompt\"\"\"\n        prompt_lower = user_prompt.lower()\n\n        # Look for patterns like:\n        # \"get request 2\", \"show me request INC-2\", \"details of request 2\"\n        # \"fetch request with id 2\", \"request number 2\"\n\n        import re\n\n        # Pattern 1: \"request 2\", \"request id 2\", \"request number 2\"\n        pattern1 = r'request\\s+(?:id\\s+|number\\s+)?(\\d+)'\n        match1 = re.search(pattern1, prompt_lower)\n        if match1:\n            return int(match1.group(1))\n\n        # Pattern 2: \"INC-2\", \"REQ-2\", etc.\n        pattern2 = r'(?:inc|req|ticket|request)[-\\s]*(\\d+)'\n        match2 = re.search(pattern2, prompt_lower)\n        if match2:\n            return int(match2.group(1))\n\n        # Pattern 3: \"id 2\", \"ID: 2\"\n        pattern3 = r'id\\s*:?\\s*(\\d+)'\n        match3 = re.search(pattern3, prompt_lower)\n        if match3:\n            return int(match3.group(1))\n\n        # Pattern 4: Just a number if context suggests it's a request\n        if any(keyword in prompt_lower for keyword in ['get', 'show', 'fetch', 'details', 'info']):\n            pattern4 = r'\\b(\\d+)\\b'\n            matches = re.findall(pattern4, prompt_lower)\n            if len(matches) == 1:  # Only if there's exactly one number\n                return int(matches[0])\n\n        return None\n\n    def is_specific_request_query(self, user_prompt):\n        \"\"\"Check if the query is asking for a specific request\"\"\"\n        prompt_lower = user_prompt.lower()\n\n        # Keywords that suggest specific request query\n        specific_keywords = [\n            'get request', 'show request', 'fetch request', 'request details',\n            'details of request', 'info about request', 'request info',\n            'inc-', 'req-', 'ticket', 'request id', 'request number'\n        ]\n\n        # Check if any specific keyword is present\n        has_specific_keyword = any(keyword in prompt_lower for keyword in specific_keywords)\n\n        # Check if there's a request ID\n        request_id = self.extract_request_id(user_prompt)\n\n        return has_specific_keyword and request_id is not None\n\n    def fetch_specific_request(self, request_id):\n        \"\"\"Fetch specific request by ID\"\"\"\n        try:\n            # Get access token\n            auth_token = self.get_access_token()\n            if not auth_token:\n                return {\n                    \"success\": False,\n                    \"error\": \"Failed to obtain access token\"\n                }\n\n            # Build URL\n            url = f\"{self.config.REQUEST_DETAIL_URL}/{request_id}\"\n\n            # Prepare headers\n            headers = {\n                'Accept': 'application/json, text/plain, */*',\n                'Accept-Language': 'en-IN,en-GB;q=0.9,en-US;q=0.8,en;q=0.7',\n                'Authorization': f'Bearer {auth_token}',\n                'Connection': 'keep-alive',\n                'Content-Type': 'application/json',\n                'Referer': f'{self.config.BASE_URL}/t/request/{request_id}',\n                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36'\n            }\n\n            # Make the API call\n            response = requests.get(\n                url,\n                headers=headers,\n                verify=False,\n                timeout=self.config.REQUEST_TIMEOUT\n            )\n\n            if response.status_code == 200:\n                request_data = response.json()\n\n                # Extract key information for summary\n                summary = {\n                    \"id\": request_data.get(\"id\"),\n                    \"name\": request_data.get(\"name\"),\n                    \"subject\": request_data.get(\"subject\"),\n                    \"description\": request_data.get(\"description\", \"\").replace(\"<p>\", \"\").replace(\"</p>\", \"\"),\n                    \"status_id\": request_data.get(\"statusId\"),\n                    \"priority_id\": request_data.get(\"priorityId\"),\n                    \"requester\": request_data.get(\"requester\"),\n                    \"requester_name\": request_data.get(\"requesterName\"),\n                    \"created_time\": request_data.get(\"createdTime\"),\n                    \"updated_time\": request_data.get(\"updatedTime\"),\n                    \"due_by\": request_data.get(\"dueBy\"),\n                    \"request_type\": request_data.get(\"requestType\"),\n                    \"tags\": request_data.get(\"tags\", [])\n                }\n\n                return {\n                    \"success\": True,\n                    \"data\": request_data,\n                    \"summary\": summary,\n                    \"api_call\": {\n                        \"url\": url,\n                        \"method\": \"GET\",\n                        \"request_id\": request_id\n                    },\n                    \"message\": f\"Found request {request_data.get('name', request_id)}: {request_data.get('subject', 'No subject')}\"\n                }\n            else:\n                return {\n                    \"success\": False,\n                    \"error\": f\"Request not found or access denied (status {response.status_code})\",\n                    \"details\": response.text,\n                    \"api_call\": {\n                        \"url\": url,\n                        \"method\": \"GET\",\n                        \"request_id\": request_id\n                    }\n                }\n\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Error fetching request: {str(e)}\",\n                \"request_id\": request_id\n            }\n    \n    def build_request_body(self, priority_ids=None, status_ids=None):\n        \"\"\"Build the request body for the API call\"\"\"\n        quals = []\n\n        # Handle status filtering\n        if status_ids:\n            # If specific statuses are requested, use them\n            quals.append({\n                \"type\": \"RelationalQualificationRest\",\n                \"leftOperand\": {\n                    \"type\": \"PropertyOperandRest\",\n                    \"key\": \"request.statusId\"\n                },\n                \"operator\": \"in\",\n                \"rightOperand\": {\n                    \"type\": \"ValueOperandRest\",\n                    \"value\": {\n                        \"type\": \"ListLongValueRest\",\n                        \"value\": status_ids\n                    }\n                }\n            })\n        else:\n            # Default: exclude closed requests (status ID 13)\n            quals.append({\n                \"type\": \"RelationalQualificationRest\",\n                \"leftOperand\": {\n                    \"type\": \"PropertyOperandRest\",\n                    \"key\": \"request.statusId\"\n                },\n                \"operator\": \"not_in\",\n                \"rightOperand\": {\n                    \"type\": \"ValueOperandRest\",\n                    \"value\": {\n                        \"type\": \"ListLongValueRest\",\n                        \"value\": [self.config.CLOSED_STATUS_ID]\n                    }\n                }\n            })\n\n        # Add priority filter if specified\n        if priority_ids:\n            quals.append({\n                \"type\": \"RelationalQualificationRest\",\n                \"leftOperand\": {\n                    \"type\": \"PropertyOperandRest\",\n                    \"key\": \"request.priorityId\"\n                },\n                \"operator\": \"in\",\n                \"rightOperand\": {\n                    \"type\": \"ValueOperandRest\",\n                    \"value\": {\n                        \"type\": \"ListLongValueRest\",\n                        \"value\": priority_ids\n                    }\n                }\n            })\n\n        return {\n            \"qualDetails\": {\n                \"type\": \"FlatQualificationRest\",\n                \"quals\": quals\n            }\n        }\n    \n    def execute_api_call(self, user_prompt):\n        \"\"\"Execute the API call based on user prompt\"\"\"\n        try:\n            # Check if this is a specific request query\n            if self.is_specific_request_query(user_prompt):\n                request_id = self.extract_request_id(user_prompt)\n                if request_id:\n                    return self.fetch_specific_request(request_id)\n\n            # Get fresh access token for search queries\n            auth_token = self.get_access_token()\n            if not auth_token:\n                return {\n                    \"success\": False,\n                    \"error\": \"Failed to obtain access token\",\n                    \"details\": \"Could not authenticate with the API\"\n                }\n            \n            # Parse the prompt\n            params = self.parse_user_prompt(user_prompt)\n            priority_ids = self.extract_priority_filter(user_prompt)\n            status_ids = self.extract_status_filter(user_prompt)\n\n            # Build request body\n            request_body = self.build_request_body(priority_ids, status_ids)\n            \n            # Build URL with query parameters\n            query_string = urlencode(params)\n            url = f\"{self.config.REQUEST_SEARCH_URL}?{query_string}\"\n            \n            # Prepare headers\n            headers = {\n                'Accept': 'application/json, text/plain, */*',\n                'Authorization': f'Bearer {auth_token}',\n                'Content-Type': 'application/json',\n                'User-Agent': 'API-Agent/1.0'\n            }\n            \n            # Make the API call\n            response = requests.post(\n                url,\n                headers=headers,\n                json=request_body,\n                verify=False,  # --insecure equivalent\n                timeout=self.config.REQUEST_TIMEOUT\n            )\n            \n            # Parse response\n            if response.status_code == 200:\n                data = response.json()\n                return {\n                    \"success\": True,\n                    \"data\": data,\n                    \"api_call\": {\n                        \"url\": url,\n                        \"method\": \"POST\",\n                        \"request_body\": request_body,\n                        \"priority_filter\": priority_ids,\n                        \"status_filter\": status_ids,\n                        \"parameters\": params\n                    },\n                    \"message\": f\"Found {len(data.get('content', []))} requests\" if isinstance(data, dict) and 'content' in data else \"API call successful\"\n                }\n            else:\n                return {\n                    \"success\": False,\n                    \"error\": f\"API call failed with status {response.status_code}\",\n                    \"details\": response.text,\n                    \"api_call\": {\n                        \"url\": url,\n                        \"method\": \"POST\",\n                        \"request_body\": request_body,\n                        \"priority_filter\": priority_ids,\n                        \"status_filter\": status_ids\n                    }\n                }\n                \n        except requests.exceptions.RequestException as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Network error: {str(e)}\",\n                \"api_call\": {\n                    \"url\": url if 'url' in locals() else \"URL not built\",\n                    \"method\": \"POST\"\n                }\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Unexpected error: {str(e)}\"\n            }\n\n# Initialize the executor\nexecutor = APIExecutor()\n\n@app.route('/execute-request', methods=['POST'])\ndef execute_request():\n    \"\"\"\n    Execute API request based on user prompt\n\n    Request body: {\"request\": \"Get all the request with priority as low\"}\n    \"\"\"\n    try:\n        # Get request data\n        data = request.get_json()\n\n        if not data or 'request' not in data:\n            return jsonify({\n                \"success\": False,\n                \"error\": \"Missing 'request' field in JSON body\",\n                \"example\": {\"request\": \"Get all the request with priority as low\"}\n            }), 400\n\n        user_prompt = data['request']\n\n        # Execute the API call (token is obtained automatically)\n        result = executor.execute_api_call(user_prompt)\n        \n        # Add metadata\n        result['user_prompt'] = user_prompt\n        result['timestamp'] = __import__('datetime').datetime.now().isoformat()\n        \n        # Return appropriate status code\n        status_code = 200 if result['success'] else 500\n        return jsonify(result), status_code\n        \n    except Exception as e:\n        return jsonify({\n            \"success\": False,\n            \"error\": f\"Server error: {str(e)}\",\n            \"timestamp\": __import__('datetime').datetime.now().isoformat()\n        }), 500\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({\n        \"status\": \"healthy\",\n        \"service\": \"API Endpoint Server\",\n        \"timestamp\": __import__('datetime').datetime.now().isoformat()\n    })\n\n@app.route('/examples', methods=['GET'])\ndef get_examples():\n    \"\"\"Get example requests\"\"\"\n    examples = [\n        {\n            \"description\": \"Get low priority requests\",\n            \"request\": {\"request\": \"Get all the request with priority as low\"}\n        },\n        {\n            \"description\": \"Get medium priority requests\",\n            \"request\": {\"request\": \"Show me medium priority requests\"}\n        },\n        {\n            \"description\": \"Get high and urgent requests\",\n            \"request\": {\"request\": \"Find high and urgent priority requests\"}\n        },\n        {\n            \"description\": \"Get all active requests (no priority filter)\",\n            \"request\": {\"request\": \"Get all active requests\"}\n        },\n        {\n            \"description\": \"Get requests with specific status\",\n            \"request\": {\"request\": \"Get all tickets that have status as in progress\"}\n        },\n        {\n            \"description\": \"Get open requests\",\n            \"request\": {\"request\": \"Show me all open requests\"}\n        },\n        {\n            \"description\": \"Get specific request by ID\",\n            \"request\": {\"request\": \"Get request 2\"}\n        },\n        {\n            \"description\": \"Get request details by name\",\n            \"request\": {\"request\": \"Show me details of request INC-2\"}\n        }\n    ]\n    \n    return jsonify({\n        \"examples\": examples,\n        \"endpoint\": \"/execute-request\",\n        \"method\": \"POST\"\n    })\n\nif __name__ == '__main__':\n    print(\"🚀 Starting API Endpoint Server...\")\n    print(\"📡 Endpoint: POST /execute-request\")\n    print(\"📋 Example: {\\\"request\\\": \\\"Get all the request with priority as low\\\"}\")\n    print(\"🔗 Health check: GET /health\")\n    print(\"📚 Examples: GET /examples\")\n    print(\"=\" * 60)\n    \n    app.run(host='0.0.0.0', port=5000, debug=True)\n","baseTimestamp":1754030165170,"deltas":[{"timestamp":1754030185275,"changes":[{"type":"INSERT","lineNumber":543,"content":"                error_message = f\"API call failed with status {response.status_code}\""},{"type":"INSERT","lineNumber":544,"content":"                if response.status_code == 502:"},{"type":"INSERT","lineNumber":545,"content":"                    error_message += \" - Server error (Bad Gateway)\""},{"type":"INSERT","lineNumber":546,"content":"                elif response.status_code == 500:"},{"type":"INSERT","lineNumber":547,"content":"                    error_message += \" - Internal server error\""},{"type":"INSERT","lineNumber":548,"content":"                elif response.status_code == 404:"},{"type":"INSERT","lineNumber":549,"content":"                    error_message += \" - Endpoint not found\""},{"type":"INSERT","lineNumber":550,"content":"                elif response.status_code == 401:"},{"type":"INSERT","lineNumber":551,"content":"                    error_message += \" - Authentication failed\""},{"type":"INSERT","lineNumber":552,"content":"                elif response.status_code == 403:"},{"type":"INSERT","lineNumber":553,"content":"                    error_message += \" - Access forbidden\""},{"type":"INSERT","lineNumber":554,"content":""},{"type":"DELETE","lineNumber":545,"oldContent":"                    \"error\": f\"API call failed with status {response.status_code}\","},{"type":"DELETE","lineNumber":546,"oldContent":"                    \"details\": response.text,"},{"type":"INSERT","lineNumber":557,"content":"                    \"error\": error_message,"},{"type":"INSERT","lineNumber":558,"content":"                    \"details\": response.text[:500] + \"...\" if len(response.text) > 500 else response.text,"},{"type":"INSERT","lineNumber":565,"content":"                    },"},{"type":"INSERT","lineNumber":566,"content":"                    \"troubleshooting\": {"},{"type":"INSERT","lineNumber":567,"content":"                        \"status_mapping_available\": len(self.status_mapping) > 0,"},{"type":"INSERT","lineNumber":568,"content":"                        \"status_mapping\": dict(list(self.status_mapping.items())[:5]) if self.status_mapping else {},"},{"type":"INSERT","lineNumber":569,"content":"                        \"filters_applied\": {"},{"type":"INSERT","lineNumber":570,"content":"                            \"priority\": priority_ids,"},{"type":"INSERT","lineNumber":571,"content":"                            \"status\": status_ids"},{"type":"INSERT","lineNumber":572,"content":"                        }"}]}]}}}